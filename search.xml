<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《Head First Java》笔记]]></title>
      <url>%2Fhead-first-java-notes%2F</url>
      <content type="text"><![CDATA[经典 Java 教材，摘录重点。 Chap 1 Java 中的 int 与 boolean 两种类型并不相容。 (P12) Chap 2 创建的对象会被存放在可回收垃圾的堆的区域中。Java 虚拟机会在内存不足时启动垃圾收集器清理垃圾并回收空间以再次利用。 (P40) Java 没有全局变量，Chap 10 会讨论让方法变成类似 global 的修饰符 public 与 static。在任何类中的任何程序都可以存取 public static 的方法。 (P41) 若有很多类要提交，可以把所有文件包装进依据 pkzip 格式来存档的 .jar 文件(Java Archive)，在 jar 文件中引入一个简单文字文件 manifest 在其中定义出 jar 中的哪个文件带有启动应用程序的 main() 方法。 (P41) Chap 3 除非末尾加上 f 否则所有带有小数点的值都会被 Java 当作 double 处理。一次声明 float 变量时应该 float a = 1.0f (P51) 8 种原始类型 (primitive types) (P51)| type | bits | range || :—–: | :————: | :———-: || boolean | depends on JVM | true/false || char | 16 | 0~65535 || byte | 8 | -128~127 || short | 16 | -32768~32767 || int | 32 | -2^31~2^31-1 || long | 64 | -2^63~2^63-1 || float | 32 | variable || double | 64 | variable | Java 只支持有符号数 Java 只支持有符号整数 编译器不允许将大类型的内容放到小类型中，但反过来可以。 (P52) 类、方法、变量的命名方法 (P53) 名称必须以字母、_ 、$ 符号开头，不能用数字开头 除第一个字符之外后面可用数字 名称要避开 Java 关键字 references to Objects 为第9种变量类型，它并不是对象的容器，而是类似指向对象的指针，或者可以说是地址。 (P54-58) 数组中可以存放 primitive types 和 references to objects，但数组本身永远一定是对象。 (P59) Chap 4 类是对象的蓝图，类所描诉的是对象知道什么与执行什么。 (P72) 实例变量永远都会有默认值。而局部变量在使用前必须初始化。 (P84-85) 使用 == 来比较两个 primitive 类型或判断两个引用是否引用同一个对象。只是比较其中的字节组合。例如： 123456int a = 3;byte b = 3;if(a == b) &#123; //此处a==b的值为true //int类型的字节组合虽然有更多的0，但此处不考虑&#125; 使用equals() 来判断两个对象是否在意义上相等。例如判断两个 String 对象是否带有相同的字节组合。 (P86) Chap 5 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习笔记]]></title>
      <url>%2Flinux-notes%2F</url>
      <content type="text"><![CDATA[Linux 是 CS 必修。 学习资料：Unix &amp; Linux大学教程 背景GNU copyleft Unix主要类型的 Unix： Linux 基于 System V (AT&amp;T) 的 Solaris 等 基于 BSD (Berkeley Software Distribution, 由 Bill Joy 开发, TCP/IP 最早实现在上面) 的 FreeBSD 和 Mac OS X（2001 年前，Macintosh 的 OS 是完全专有的，2001 年苹果公司采用了基于 Unix 的OS X） 为什么输入网址时必须注意大小写？因为大多数 Web 服务器运行在某种类型的 Unix 系统上，而 Unix 系统是区分大小写的。 待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习笔记]]></title>
      <url>%2Fpython-notes%2F</url>
      <content type="text"><![CDATA[学习 Python 时记的笔记 学习路径 《Python编程快速上手——让繁琐工作自动化》真是相当好的入门书，我之前看过《笨方法学Python(Learn Python the hard way)》、《Python简明教程(A byte of Python)》，都十分不满意，虽然这两本书人气很高评价也不错。 如果有进一步学习我会写上，记录完整的路径 基本语法输入输出 print() 打印输出 input() 默认的返回值类型为 string 数据类型数字类型 操作符 作用 ** 指数 % 取余 // 整除 / 除法 * 乘法 - 减法 + 加法 float1234&gt;&gt;&gt; 0.2 + 0.10.30000000000000004&gt;&gt;&gt; 3 * 0.10.30000000000000004 布尔类型 True False 用于条件时，0、0.0、&#39;&#39;(空字符串)会被认为是 False，其他值被认为是 True NoneType None表示没有值，其他语言可能称这个值为null、nil、undefined print() 的返回值就是 None在幕后，对于所有没有 return 语句的函数定义，Python都会在末尾加上 return None，类似于 while 或 for 循环隐式地以 continue 语句结尾。 使用不带值的 return 语句，那么就返回 None。 string123456789s = ' I love you 's.title() == ' I Love You 's.upper() == ' I LOVE YOU 's.lower() == ' i love you 's.rstrip() == ' I love you's.lstrip() == 'I love you 's.strip() == 'I love you'len(s) == 12 类型转换 str() int() float() 比较1234&gt;&gt;&gt;'10' == 10False&gt;&gt;&gt;'10.0' == 10True 布尔操作符优先级：not &gt; and &gt; or 控制流12345678910111213141516171819202122232425262728293031323334353637383940# 分支语句if 条件: 代码块elif 条件: 代码块else: 代码块# while 循环while 条件: 代码块# for 循环# 此例中 i 在 5 次迭代中分别被设置为 0,1,2,3,4for i in range(5): 代码块# range()# 2个参数: 这会把[1,6)内的整数依次传递给 range()，注意左闭右开for i in range(1,6) print(i) # 3个参数: 第3个参数为步长，此例输出0,2,4,6,8for i in range(0,10,2) print(i)# 还可以将步长设置为负数，让循环计数逐渐减小，此例输出5,4,3,2,1,0for i in range(5,-1,-1) print(i)# break 和 continue 与 C语言用法一样# 提前结束程序import syswhile True: print('Type exit to exit') response = input() if response == 'exit': sys.exit() print('You typed' + response + '.') # 程序运行时可使用 Ctrl+C 来马上停止程序 函数1234# 自定义函数def 函数名(参数): 函数体 return 返回值 关键字参数某些函数有可选的关键字参数，在函数调用时可以指定。也可以在自己编写的函数中添加关键字参数，但必须先学习列表和字典数据类型关键字参数常用于可选变元 print() 的关键字参数 end 关键字参数 123&gt; print('hello')&gt; print('world')&gt; &gt; 输出将会是： hello world 因为print()函数自动在传入的字符串末尾添加了换行符，但是可以设置 end 关键字参数 123&gt; print('hello', end='')&gt; print('world')&gt; &gt; 输出将会是： helloworld123456789101112- sep 关键字参数&gt; ```pythonprint('how', 'are', 'you')# 输出将会是：how are you# 因为 print() 函数自动在传入的多个字符串之间用一个空格分割他们# 但是可以设置 sep 关键字参数，替换掉默认的分隔字符串print('how', 'are', 'you', sep=',')# 输出将会是how,are,you 作用域global 语句用来在函数内修改全局变量 数据结构列表 列表值是列表本身 负数下标：-1为最后一项 切片：li[a:b]的值为[a,b)区间内的元素，省略第一个参数相当于使用0，省略第二个参数意味着直至列表的末尾 添加：li.append() 插入：li.insert(index, sth) 求长：len()取得列表中值的个数 删除： del语句删除列表中下标处的值，如 del list[2] li.pop(index) 删除并返回删除项 li.remove(value) 删除值，只删除第一个 排序： sort() sorted() reverse() ​ 高级特性模块内建函数不需要导入，可以直接调用的基本函数，比如： print() input() len() 导入模块 import 模块导入后可使用该模块所有函数，函数名称前要加上 模块名. from 模块 import *使用这种方法不需要加 模块名. 前缀 异常处理程序中遇到错误或异常会让整个程序崩溃，使用异常处理可以检测错误并处理它们然后继续运行 1234567891011121314def spam(divideby): try: return 42 / divideby except ZeroDivisionError: print('ERROR')print(spam(2))print(spam(0))print(spam(5))# output21.0ERRORNone8.4 一旦执行到 except 子句的代码，就不会回到 try 子句 常见异常： ZeroDivisionError: 除零错误 ValueError: 比如在 int(‘string’)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenCV学习笔记(二) 图像与视频的读写与显示]]></title>
      <url>%2Fopencv-notes-2%2F</url>
      <content type="text"><![CDATA[OpenCV系列笔记第二篇。介绍图像与视频的输入输出 写在前面我在学习OpenCV的过程中，主要参考了以下资料： OpenCV3编程入门 虽然这本书写的很没有诚意而且各种抄袭，但 新手翻阅一下能学到一些东西 Learning OpenCV 3 著名的参考书，在 OpenCV1 时代就是重要的学习资料，如今随着3版本更新了。此书还没有中文版。 官方文档 如果你发现了本文中的错误或者没说清楚的地方，欢迎在下方评论。 图像输入输出12345678#include &lt;opencv2/opencv.hpp&gt;using namespace cv;int main() &#123; Mat img = imread("1.jpg"); imshow("原图", img); waitKey(); return 0;&#125; 头文件首先前两行属于固定开头，并且这个写法是最简洁的。头文件 opencv.hpp 中包含了openCV其余各个模块头文件声明，所以不必再include其他头文件。 命名空间OpenCV中的类和函数都在命名空间cv中 数据结构在OpenCV中，使用Mat类来保存图像。图像在计算机中是以矩阵的格式存储的，所以Mat本质上是一个矩阵的类，每一个像素都有它的列数和行数。Mat类还可作为代数矩阵并执行操作(如矩阵加法、乘法、创造一个对角矩阵)Mat类对应于以前C语言版本的OpenCV中的IplImage结构体，但Mat不必再手动开辟空间和释放内存。 图片的读写读取图像的函数 imread() 原型如下1Mat imread(const string&amp; filename, int flags=1 ); 第一个参数是文件名，要放在双引号中第二个参数是载入标识，默认为1，表示载入三通道的彩色图像。一般会省略 写图像的函数 imwrite()第一个参数是带有扩展名的保存路径第二个参数是要保存的图像对象名上面的最简OpenCV程序没有用到，但还是在这一并介绍了 显示图像的函数 imshow()函数 原型如下1void imshow(const string&amp; winname, InputArray mat); imshow()函数会创建一个窗口来显示图像第一个参数是窗口的名字第二个参数是要显示的图像对象名 等待waitKey()等待用户按任意键停止程序其中参数是等待的毫秒数，设置为0表示永远等待 视频输入输出读取视频文件1234567891011121314151617181920#include &lt;opencv2\opencv.hpp&gt; using namespace cv; int main() &#123; //读入视频 VideoCapture capture("1.avi"); //写法1 /* 写法2：先实例化再初始化 VideoCapture capture; capture.open("1.avi"); */ //循环显示每一帧 while(1) &#123; Mat frame; capture&gt;&gt;frame; //读取当前帧到frame变量 if (frame.empty()) //判空 break; imshow("视频",frame); waitKey(1); &#125; return 0; &#125; 调用摄像头来读取视频只需要把上面程序中的 VideoCapture capture(&quot;1.avi&quot;); 换成 VideoCapture capture(0) 即可表示调用摄像头来读取视频]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenCV学习笔记(一) OpenCV 模块]]></title>
      <url>%2Fopencv-notes-1%2F</url>
      <content type="text"><![CDATA[OpenCV系列笔记第一篇。 OpenCV 各模块的简介 OpenCV采用模块化的架构设计，我们打开\opencv\sources\modules可以看到OpenCV的各个模块，每个模块包含不同的内容。 主要模块按照官方文档的顺序列举主要模块 Module Feature core The Core Functionality imgproc Image Processing highgui High Level GUI and Media imgcodecs Image Input and Output videoio Video Input and Output calib3d Camera calibration and 3D reconstruction(相机校准和3D重建) feature2d 2D Features framework video Video analysis objdetect Object Detection ml Machine Learning photo Computational photography stitching Images stitching(图像拼接) cuda GPU-Accelerated Computer Vision 还有其他一些不常用的模块，这里就不一一列举了。 头文件要在程序中使用OpenCV，我们需要包含头文件。在程序的开始，我们只需要添加一句 #include &lt;opencv2/opencv.hpp&gt; 即可，而没有必要像网上一些示例程序一样包含好几个模块头文件。这是因为 opencv.hpp 中已经包含了所有的模块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenCV学习笔记(零) VS2017与OpenCV3的安装]]></title>
      <url>%2Finstall-vs2017-and-opencv3%2F</url>
      <content type="text"><![CDATA[OpenCV系列笔记第零篇。开发环境搭建教程 下载宇宙最强IDE VS2017社区版 免费OpenCV 3.2.0 版本：下载地址 自己选择安装目录，下文中使用 \opencv 代表你的安装目录。 配置我的电脑是64位的，相信大部分人的PC都是64位，所以按照64位来说。 添加环境变量此电脑 右键&gt;属性&gt;高级系统设置&gt;环境变量&gt;选中Path编辑&gt;在变量值末尾增加 \openCV\build\x64\vc14\bin如下图所示，按红色序号来 配置动态链接库一步简单的复制粘贴找到 \opencv\build\x64\vc14\lib\ 目录，将文件全部选中，拷贝至c:\Windows\SysWOW64 文件夹下 工程目录配置在VS2017中新建空项目，并设置x64，debug模式。进入属性窗口，如下： 包含目录在包含目录中添加如下内容 库目录在库目录下添加如下内容 附加依赖项找到链接器&gt;输入，在附加依赖项中添加如下内容 测试新建一个C++文件，输入下面这段代码，注意把图片放在你的工程所在目录12345678#include &lt;opencv2/opencv.hpp&gt;using namespace cv;int main() &#123; Mat img = imread("1.jpg"); imshow("原图", img); waitKey(); return 0;&#125; 按Ctrl+F5运行。如果成功的话会看到如下窗口恭喜你，安装成功，开始下一步的学习吧~如果上面的程序看不懂，可以看我下一篇博文的讲解：OpenCV学习笔记(二) 图像与视频的读写与显示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浪潮之巅读书笔记]]></title>
      <url>%2Fon-top-of-tides%2F</url>
      <content type="text"><![CDATA[整理读书笔记 读完了第三版上册，图书馆里的下册被别人借走了。以后再看吧~ 科技公司 Company Founded Nokia 1865- General Electric 1892- 3M 1902- IBM 1911- Motorola 1928- Hewlett-Packard 1939- Intel 1968- Microsoft 1975- Apple 1976- Oracle 1977- SUN 1982-2010 Cisco 1984- DELL 1984- Yahoo! 1994- Netscape 1994-2003 Amazon 1994- eBay 1995- Google 1998- Tencent 1998- Facebook 2004- AT&amp;TAlexander Bell 于 1875 年发明实用电话，1877 年创立贝尔电话公司，反垄断拆分后公司主体采用 AT&amp;T 的名称。 Bell Labs: 晶体管 William Bradford Shockley Jr. Unix &amp; C 1972 信息论 Claude Elwood Shannon DSL最初诞生于贝尔实验室，John Cioffi 后来在 Stanford University 将它实用化，成为“DSL之父” 射电天文望远镜、数字交换机、电子的波动性、第一颗商用通信卫星、第一条商用光纤等 Microsoft 游戏机领域：1990s 以前，基本上是任天堂（低端）和索尼（高端）的天下，从 1997 年起，微软大举进军游戏机市场。 为了满足在互联网上建立网站和开发应用程序的需求，太阳搞出了基于 Java 的 JSP 开发环境，微软针锋相对，以自家 Visual Basic 为基础推出了 ASP 技术 Oracle Oracle 本意是预言家，进入中国后，选择甲骨文作为公司的中文名称。 微软在 PC 领域，甲骨文在企业级市场，分别树立起“不生产硬件，只靠软件的使用费赚钱”的商业模式。 09 年收购 SUN，MySQL 也成为 Oracle 旗下产品。 Cisco 名字来源于旧金山(San Francisco)的最后5个字母，标志是旧金山的金门大桥。 靠多协议路由器起家。 为防止患上不思进取的大公司病，采用内部创业的独特方法。 2015 年底，华为超过思科成为全球最大的电信和网络设备公司。 Yahoo! 雅虎公司开启了互联网时代的商业模式 dot-coms: 互联网公司 Motorola Motor 代表汽车，ola 是美国很多商品常用的后缀，比如 Coca Cola 通信分类 分类 应用 公司 有线单向 闭路电视 AT&amp;T 有线双向 电话 AT&amp;T 无线单向 收音机 RCA 无线双向 手机 Wi-Fi Motorola 2004 年，高尔文下台时，半导体部门被迫分离出去单独上市，就是现在的飞思卡尔(Freescale)，后在德州仪器和高通公司的挤压下被私募基金收购。 2014 年，Google 将其分公司摩托罗拉出售给联想 投资公司 世界上最大的风险投资公司 KPCB、红杉资本在硅谷 摘录 人类历史上最富有的75人中，$1\over5$ 出生在1830-1840 年的美国，包括卡内基洛克菲勒，年富力强时赶上了美国内战后的工业革命。1950-1970 出现乔布斯盖茨太阳谷歌创始人，赶上信息革命。 Peter Norvig 定律：当一家公司的市场占有率超过 $50\%$ 以后，就不要再指望在市场占有率上翻番了。 “在命运降临的伟大瞬间，市民的一切美德——小心、顺从、勤勉、谨慎，都无济于事，它始终只要求天才人物，并且将他造就成不朽的形象。命运鄙视地把畏首畏尾的人拒之门外。命运——这世上的另一位神，只愿意用热烈的双臂把勇敢者高高举起，送上英雄们的天堂。” ——《人类的群星闪耀时》 几个时间 大萧条：1929-1933 互联网泡沫：2000-2001，90%的互联网公司倒闭 美国西部淘金热：1828、1835、1842 在加州圣地亚哥、旧金山、洛杉矶先后发现了金矿。 Java：1995年，太阳公司推出 补充知识 美国行政划分：联邦分为州和特区，州分为县，县分为市和镇 ARM：Advanced RISC Machines 希腊是欧洲文明的摇篮，文化科学艺术发达；罗马学习了希腊很多东西并打败了希腊，建设了强大的帝国，但创新不多 陆奇： FDU CS 学士 硕士 CMU CS Ph.D 1998年 雅虎 2007年晋升为雅虎执行副总裁 2009年 微软 网络服务集团总裁，做Bing，2013年出任微软集团全球执行副总裁 2017年 百度 百度集团总裁兼首席运营官、百度董事及董事会副主席，兼任百度智能驾驶事业群组总经理 加州经济产值占美国GDP的1/6 160多年前旧金山是淘金者的天下，一个叫 Levi Strauss 的德国人也从纽约跑到这里淘金，发现淘金者过剩后捡起原来布料商和裁缝的老本行，用做帐篷的帆布为淘金者做结实的工作服，这就是现在世界上最有名的 Levi’s 牛仔裤 仙童半导体是从 Shockley Semiconductor 集体叛逃的八叛徒创办的。其中有Intel公司的创始人、摩尔定律的提出者戈登·摩尔，有集成电路的发明人 Robert Noyce 1979年，施乐公司的帕洛阿尔托实验室里几位发明了以太网的科学家创办了3Com公司，开发出以太网(Ethernet)的适配器(Adaptor)，俗称网卡]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 $TeX$ 编辑数学公式]]></title>
      <url>%2FMathjax%2F</url>
      <content type="text"><![CDATA[本文介绍使用 $Tex$ 编辑数学公式适用于 $\LaTeX$ 、Mathematics 、支持MathJax的网页 使用场景$\LaTeX$暂时还不会，不过公式的写法是相通的。 MathJaxWhat is MathJax ? A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works. How to use MathJax ? There are two types of equations: ones that occur within a paragraph (in-line mathematics), and larger equations that appear separated from the rest of the text on lines by themselves (displayed mathematics). The default math delimiters are $$...$$ and \[...\] for displayed mathematics, and \(...\) for in-line mathematics. Note in particular that the $...$ in-line delimiters are not used by default. That is because dollar signs appear too often in non-mathematical settings, which could cause some text to be treated as mathematics unexpectedly. 此外，可以在渲染完成的公式上方右键点击，唤出右键菜单。在菜单中提供了查看公式代码、设置显示效果和渲染模式的选项。 上标与下标上标和下标分别使用^与_，例如x_i^2：$x_i^2$ 。默认情况下，上下标符号仅仅对下一个组（即单个字符或者使用{}包裹起来的内容）起作用。例如，如果使用10^10，会得到$10^10$，所以此处应写成10^{10} 括号字体初等数学常用符号微积分常用符号矩阵希腊字母 Name Upper $Tex$ Lower $Tex$ alpha $A$ A $\alpha$ \alpha beta $B$ B $\beta$ \beta gamma $\Gamma$ \Gamma $\gamma$ \gamma delta $\Delta$ \Delta $\delta$ \delta epsilon $E$ E $\epsilon$ \epsilon zeta $Z$ Z $\zeta$ \zeta eta $H$ H $\eta$ \eta theta $\Theta$ \Theta $\theta$ \theta iota $I$ I $\iota$ \iota kappa $K$ K $\kappa$ \kappa lambda $\Lambda$ \Lambda $\lambda$ \lambda mu $M$ M $\mu$ \mu nu $N$ N $\nu$ \nu xi $\Xi$ \Xi $\xi$ \xi omicron $O$ O $\omicron$ \omicron pi $\Pi$ \Pi $\pi$ \pi rho $P$ P $\rho$ \rho sigma $\Sigma$ \Sigma $\sigma$ \sigma tau $T$ T $\tau$ \tau upsilon $\Upsilon$ \Upsilon $\upsilon$ \upsilon phi $\Phi$ \Phi $\phi$ \phi chi $X$ X $\chi$ \chi psi $\Psi$ \Psi $\psi$ \psi omega $\Omega$ \Omega $\omega$ \omega 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web学习笔记]]></title>
      <url>%2Fweb-notes%2F</url>
      <content type="text"><![CDATA[整理一下学习 Web 开发时学到的东西 学习路径 freeCodeCamp Head First HTML and CSS 第二版 JavaScript入门经典 第五版 JavaScript面向对象编程指南 第二版 w3school HTML一般模板：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; //meta元素要在head中所有元素的最上 &lt;title&gt;xxx&lt;/title&gt; &lt;link rel="stylesheet" href="xxx.css"&gt; //不必使用&lt;style type="text/css"&gt;&lt;/style&gt;标签了&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 验证工具： http://validator.w3.org 元素分为 inline 内联元素：不换行 和 block 块元素：自动换行 列表：123&lt;ol&gt;ordered list&lt;ul&gt;unordered list&lt;li&gt;list item 可用css控制&lt;li&gt;的样式1234li &#123; list-style-type: disc; //circle,square,none //list-style-image: url(); //使用定制标记&#125; 引用：12&lt;q&gt;&lt;/q&gt; 内联引用&lt;blockquote&gt;&lt;/blockquote&gt; 块引用 强调：12&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt; 1&lt;del&gt;文本中间划线&lt;/del&gt; &lt;a&gt;&lt;/a&gt;123属性target="_blank" 会在新窗口打开属性title会在鼠标悬停时出现提示&lt;a href="#top"&gt;Back to top&lt;/a&gt; 可以跳转到当前页面id="top"的位置 &lt;img&gt;内联元素src 属性指定图像文件的位置alt 属性会在图像不能显示时取代图像width 和 height 属性指定图像宽度高度浏览器如何处理：显示html文件后会从Web服务器获取图像，然后图像会取代img元素格式： JPEG 有损、不支持透明度 PNG 无损、支持透明度 、擅长logo和文本图像 GIF 无损、支持一种颜色透明、最多256种颜色、Web最早的图像格式 字符实体character entity: www.w3schools.com/tags/ref_entities.asp字符 实体名 编号1234&lt; &amp;lt;&gt; &amp;gt;&amp; &amp;amp;cc &amp;copyright; 视频参考w3school HTML5视频 和 HTML video标签不同浏览器支持不同的容器与编解码器，解决方案是在 &lt;video&gt; 元素中嵌套多个 &lt;source&gt; 元素，浏览器会选择它支持的第一种格式 表格参考w3school 表单参考w3school向服务器发送数据： POST: 打包表单变量，在后台发送到服务器。用户在浏览器地址栏只能看到服务器脚本的URL。数据量限制宽松GET: 打包表单变量，把数据追加到URL的最后，然后向服务器发送一个请求。适用于用户可以加书签的情况 既然是向服务器发送数据，为什么这种方法叫GET？答：浏览器的主要任务是从服务器得到Web页面，不过有表单时会在URL最后追加一些数据，除此之外，浏览器会把它当做一个普通请求来处理。 CSS层叠来自多个样式表的样式都会层叠在页面上，也就是一个页面可能会有多个样式表。按优先顺序分为作者的、用户的、浏览器默认样式。用户可以在属性声明后加上 !important 来覆盖作者样式对于冲突的规则，按照他们在各自样式表中出现的顺序进行排序 控制字体：font-family: 五大系列(不是真正的字体)： sans-serif: Verdana / Geneva(Mac) / Arial(都很常见) 高雅传统 serif: Times(Mac) / Times New Roman / Georgia 清晰可读 monospace: Courier(Mac) / Courier New / Andale Mono 等宽，用于代码 cursive: Comic Sans / Apple Chancery 类似手写，用于标题 fantasy: LAST NINJA / Impact 装饰性 使用： 候选字列表，逗号分隔，字体名字有多个单词要加””，最后放一个通用的字体系列名 字体属性font-size 14px指定的是高度；150%指定相对父级；1.2em指定比例；关键字small,medium,largefont-weight 加粗使用bold正常使用normal；还可以使用相对bolder和lighterfont-style 斜体italic是专门设计的倾斜字符；倾斜文本oblique是浏览器将文字倾斜color 大约150个颜色名 / rgb( %, %, %) / rgb(255, 255, 225) / #ffffff 其中#aabbcc格式可以缩写成#abctext-decorationunderline下划线 / line-through中间穿过的线 / none没有任何装饰 / underline overline既有上划线又有下划线，但两个不同的规则不会累加line-height 行间距ledding1.6em表示字体大小的1.6倍text-align: center; 只能在块元素中设置，对其中所有的内联元素(包括图像)起作用 Web字体:.ttf 经常作为候选.otf 建立在ttf基础上比ttf新.svg Scalable Vector Graphics一种通用图像格式.woff Web open font format支持最广泛在CSS中添加12345@font-face &#123; font-family: ""; src: url(""), url("");&#125; 盒模型：CSS将每个元素看作由一个盒子表示 content 内容区-内容与边缘之间没有边界 padding 内边距-可选，透明，无颜色无装饰 padding: top right buttom left border 边 框-可选，一条线，可利用CSS控制宽度颜色样式 border-style: solid/double/groove/outset/dotted/dashed/inset/ridge border-width: thin/medium/thick/15px border-color: border-radius: 15px/3em/ margin 外边距-可选，透明，无颜色无装饰，可以用来增加同一页面不同元素间的距离 背景图12345.class &#123; background-img: url(http://xxx/xxx.gif); background-repeat: no-repeat; background-position: top left;&#125; class 与 id class 标识一组类名要以字母开头 id 标识唯一id名可以以字母或数字开头 检查媒体&lt;link&gt;元素中的media属性可以检查媒体，据此连接不同的样式表 或者直接在CSS中增加媒体查询1234@media screen &#123;&#125;@media print &#123;&#125; &lt;div&gt;和&lt;span&gt;&lt;div&gt; 为块内容创建逻辑划分； &lt;span&gt; 为内联内容创建逻辑划分用下面的方式为某一块的某元素进行选中并更改样式12#father-id child &#123;&#125; 改变链接样式改变不同状态的颜色12345678910a:link &#123; color: grenn;&#125;a:visited &#123; color: red;&#125;a:hover &#123; background: red; color: yellow;&#125; 虚下划线12345a:visited &#123; color: #675c47; text-decoration: none; border-bottom: thin dotted #675c47;&#125; 布局和定位流：块元素从上向下流，内联元素从左到右流 左右内联元素间的距离 = 左元素外边距 + 右元素外边距上下块元素间的距离 = max(上元素下外边距,下元素上外边距)通常不会设置内联元素的外边距，除了图像。图像会设置内边距、边框、外边距。 浮动：浏览器正常的将元素流入页面，遇到浮动元素会把尽可能放在指定的边上。还会在正常流中删除这个元素，好像它浮在页面上一样。其他块元素会填在这里，但其中的内联元素定位时会考虑浮动元素的边界，因此会围绕着浮动元素。设置外边距使左右两栏分开解决层叠问题： clear: right; 表示footer右面不允许有浮动内容 浏览器特定的CSS属性浏览器用来测试新特性增加的新功能，或还没有得到标准组织批准的CSS扩展，长这样：1-webkit-transform: rotate(45deg); 服务器端脚本PHP/Python/Perl/Node.js/Ruby on Rails/JavaServer Pages/VB.NET/ASP.NET 5月678日三天看完HeadFirstHTMLandCSS，暂时放下Web的学习，先去做毕设 JavaScriptJavaScript这个术语通常涵盖了3个部分 ECMAScript: 语言核心部分，独立于浏览器。 DOM(Document Object Model): 提供一种与HTML、XML文档交互的方式。W3C创建了DOM标准，是一种独立于JS的操作结构化文档的方式 BOM(Boswer Object Model): 一个与浏览器环境有关的对象集合，HTML5之后定义了一些浏览器之间通用的对象标准 脚本使用场合 使用 &lt;script&gt; 标签在 HTML 页面中插入 JavaScript。从 &lt;script&gt; 开始到 &lt;/script&gt; 结束。 可以在 HTML 文档中放入不限数量的脚本。放在 HTML 的 &lt;body&gt; 或 &lt;head&gt; 部分中，或者同时存在于两个部分中。通常把函数放入 &lt;head&gt; 部分中，或者放在页面底部，这样就不会干扰页面的内容。 还可以使用 &lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt; 引入外部 JavaScript 文件。 一些老代码可能会在 &lt;script&gt; 标签中使用 type=&quot;text/javascript&quot;，但现在 JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言，只有在不适用 JavaScript 编写时才包含type属性。 数据类型五种基本类型 number 范围[5e-324,1e308] 超出后变成Infinity。Infinity-Infinity会得到NaN(Not a Number) string \u后面的字符会被视为Unicode码 boolean undefined 一般没有返回值的表达式会打印一个undefined null非基本类型 对象查看类型操作符typeof 可以在变量名的任意位置使用\$ 面向对象JS没有类。一切都是基于对象的，依靠一套原型(prototype)系统。不同于传统OO语言，类似“基于A类创建了一个叫做B的新对象”的描述会在JS中变成“将现有的A对象扩展成了一个叫做B的新对象”JS所有方法和属性都是public的。但还是提供了一些隐藏数据的方法。聚合和继承都发生在对象之间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[计算机系统学习资料汇总]]></title>
      <url>%2Flearn-computer-system%2F</url>
      <content type="text"><![CDATA[学习计算机系统（程序、组成原理、操作系统），写出更好的代码 计算机系统导论先上一门导论课，把软件硬件串起来，为后面深入学习构建一个Big Picture。为什么要上导论课？看下图，这是 CMU 的课程体系，可以看出这门课非常非常非常重要 那么如何学习这门导论课呢？首先需要有 C 语言基础，然后可参考下面几个资料学习： 《深入理解计算机系统》 大名鼎鼎的CSAPP CMU的计算机导论课教材，出自CS系主任之手。 可选择的辅助教程(以下课程的参考教材全是CSAPP) CMU的 Introduction to Computer Systems 包含了讲义，视频，Project和各种资料。没有字幕，英语好的同学可以跟。 华盛顿大学的The Hardware/Software Interface 使用CSAPP做教材，把经典的几个Project都引入了。 这门课在Coursea上开过，可以在课程图谱的博客上找到当时的视频和字幕(英文)。比较适合英语一般的同学。 计算机系统基础(一)：程序的表示、转换与链接计算机系统基础(二)：程序的执行和存储访问 南京大学袁春风老师的课，内容和CSAPP一致。 汇编语言 汇编语言(第3版) 王爽的汇编教材，据称是国人写的最好的计算机教材。 x86汇编语言 : 从实模式到保护模式 也是一本很好的汇编教材。 操作系统 Operating Systems: Three Easy Pieces可能是最好的操作系统教材，据说简单易读，文笔很好。 哈工大操作系统MOOC加实验 Orange’S:一个操作系统的实现 如果你想动手写一个，推荐这本。 计算机组成原理 计算机组成与设计 硬件/软件接口美国经典教材，对应国内的计算机组成原理，也就是硬件部分。我把本书的拓展阅读和习题答案等整理好放在了GitHub上，有需要可以 Star Nand2Tetris这是一本课本，中译名计算机系统要素 : 从零开始构建现代计算机。这还是一个Coursea课程，分为两个Part，第一个部分讲的是从逻辑门开始搭建出一台计算机，第二部分讲的是从这台计算机上写出俄罗斯方块游戏。如果跟下来会计算机系统有非常直观的理解。 计算机体系结构 计算机体系结构·量化研究方法属于计算机组成原理的进阶，与上面那本硬件/软件接口出自同两人之手 科普性质的书如果是想系统学习，直接去啃上面的大鱼大肉；如果是业余选手，想要简单了解一下神秘的计算机，推荐下面两本科普书，一英一中，范围内容差不多。 编码的奥秘 穿越计算机的迷雾]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++学习笔记]]></title>
      <url>%2Fc-plus-plus-notes%2F</url>
      <content type="text"><![CDATA[学习C++时所作的笔记。 参考资料： C++程序设计（原书第3版） C++ Primer 中文版（第 5 版） 基本： 震惊！cout居然是console output的简写。endl是end line的简写。 命名空间： 定义命名空间 123456namespace A &#123; int a = 1; void fun() &#123; //todo &#125;&#125; 数据类型： long long与long的区别：(等看过C++Primer后整理) #include &lt;limits&gt; 中定义了一些非常有用的常量： INT_MIN、INT_MAX、LONG_MIN、LONG_MAX、FLT_MIN、FLT_MAX、DBL_MIN、DBL_MAX sizeof()可用于类型名也可以用于变量、对象 前缀0表示八进制整数，前缀0x表示十六进制整数 浮点数的名字由来：带小数点的数值，用科学计数法表示时，小数点的位置浮动了。 类型转换： 显式转换(Explicit Conversion) 转换运算符： static_cast&lt;type&gt;(value),其中value是一个变量/字面常量/表达式 C-style cast：(int)value 强制转换(Cast)：显式转换的另一种说法(大坑 隐式转换(Implicit Conversion) 溢出： overflow：数据超过类型最大值或低于最小值。 underflow：浮点数太小(太接近于0)被近似为0 浮点数有精度，涉及浮点数的计算会导致四舍五入误差，因此，浮点数之间判断相等是不可靠的。解决方案： 123const double EPSILON = 1E-14; //const float EPSILON = 1E-7;if( abs(a-b) &lt; EPSILON ) //使用abs()需要#include &lt;cmath&gt; cout&lt;&lt;"a = b"; 简化bool变量赋值： 1234if ( number%2 == 0) even = true;else even = false; 写成下面这样会好一点：bool even = number%2 == 0;直接输出：cout &lt;&lt; (num % 2 == 0 ? &quot;num is even&quot; : &quot;num is odd&quot;); 变量 C++支持形如int a(1);的语法来声明并初始化变量，等价于int a = 1; 变量作用域： 局部静态变量：函数结束执行后局部变量会自动销毁，可使用静态局部变量保留。使用方法：变量声明语句最前加static关键字 库函数 生成随机整数： 1234567#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;int main() &#123;srand(time(0)); //以time(0)为种子cout &lt;&lt; rand()%10; //生成1~9的随机整数&#125; 数学函数： ceil(x) x被向上取整 ， floor(x) x被向下取整，返回的整数是double类型 字符函数：需要#include &lt;cctype&gt; isdigit(ch) 数字，返回true isalpha(ch) 字母，返回true isalnum(ch) 字母或数字，返回true islower(ch) issupper(ch) 判断大小写 isspace(ch) 判断空格 tolower(ch) tosupper(ch) 转换大小写 字符串与数字的转换：需要#include &lt;cstdlib&gt; atoi(s) 将C字符串转换为int类型的整数 atof(s) 将C字符串转换为浮点数 一维数组： 数组大小必须为常量。有时算法题要根据输入来决定数组大小，解决方法是开辟一个大数组或者使用vector类 数组初始化： 数组声明和初始化必须在同一语句 以初始化语句创建一个数组时允许省略数组大小 允许只初始化一部分元素，其余元素被赋予0 未被初始化的数组，元素值都不确定 数组边界不会被检查，要小心越界 String类： 连接： string s3 = s1 + s2; 可以 string s += &quot;blabla&quot;; 可以 string s = &quot;abc&quot; + &quot;def&quot;; 是非法的 比较： ==、!=、&lt;=、&gt;、=、&lt;、&gt; 读： cin &gt;&gt; s; 以空白字符结束，如果字符串中有空格则无法正确输入 #include &lt;string&gt;中的 getline(cin, s) 第三个参数默认值为 ‘\n’ ，可以读入空格 格式化输出：cout： setprecision(n) 指定浮点数显示的总位数，cout&lt;&lt;setprecision(3)&lt;&lt;12.34567; 会输出12.3 宽度不够整数部分，setprecision将被忽略，cout&lt;&lt;setprecision(3)&lt;&lt;23456; 会输出23456 精度不改变，会一直保持效果 fixed 计算机自动使用科学计数法来显示长浮点数，使用fixed强制使用费科学计数法，默认显示到小数点后6位 使用cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;可控制显示到小数点后2位 showpoint 强制显示小数点 setw(width) 指定最小占用宽度，只影响接下来的一次输出 left和right setw(width)默认输出右对齐，使用lift可设置为左对齐 printf：文件输入输出： 需要 #include &lt;fstream&gt; 读取文件： 123ifstream input("filename.txt"); //创建一个对象并打开文件，如果文件不存在会出现unexpected errorinput&gt;&gt;var1&gt;&gt;var2; //读入数据，与cin类似input.close(); //关闭文件 写入文件： 123ofstream output("filename.txt");//创建一个对象并打开文件,如果文件已经存在，内容会销毁并重新创建output&lt;&lt;var1&lt;&lt;var2; //读入数据，与cout类似output.close(); //关闭文件 输入输出重定向：Redirection.exe &lt; input.txt &gt; output.txt可以从input.txt获取输入并把输出发送到output.txt 函数重载：必须有不同的参数列表，而不能依据不同的返回类型重载。 内联函数：编译器将代码复制到每个调用点，避免函数调用的开销。适用于短函数，而多次调用的长函数可能会被编译器忽略inline关键字。 STL容器 顺序容器(一级容器)线性数据结构：多个元素的有序集合 vector：直接访问任意元素，快速插删尾部元素 deque：直接访问任意元素，快速插删头尾元素 list：快速插删任意元素 关联容器(一级容器)可快速定位元素的非线性数据结构 set：无重复关键字 multiset：允许重复关键字 map：键值对映射，无重复关键字 multimap：允许重复关键字 容器适配器顺序容器的受限版本，处理特殊情况 stack queue priority_queue 容器共同函数 无参有参拷贝构造函数，析构函数 empty() size()：返回当前元素数量 = &lt;,&lt;=,&gt;,&gt;=,==,!= 一级容器函数 c1.swap(c2)：交换c1,c2 c1.max_size()：返回可容纳最大元素数量 c.clear()：删除所有元素 c.begin()：返回首元素迭代器 c.end()：返回尾元素之后位置的迭代器 c.rbegin()：返回尾元素的迭代器，用于逆序遍历 c.rend()：返回首元素之前位置的迭代器，用于逆序遍历 c.erase(beg,end)：删除beg~end-1的元素 迭代器用于访问和处理一级容器中的元素 算法类构造函数通过调用构造函数来初始化对象。 构造函数名必须与类名相同 构造函数没有返回类型(void也不行) 可被重载 数据域初始化作为类成员，数据域不能再声明时进行初始化 构造函数 初始化列表 对象数据存储在对象里，而函数是这个类所有对象共享的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Toy programs]]></title>
      <url>%2FToy-programs%2F</url>
      <content type="text"><![CDATA[收集一些代码段。 isPrime123456789101112bool isPrime(int n) &#123; if (n == 2) return true; if (n % 2 == 0) return false; int sq = (int)sqrt(n); for (int i = 3; i&lt;=sq; i += 2) &#123; if (n % i == 0) return false; &#125; return true;&#125; isPalindrome方法1：123456bool isPalindrome(string a) &#123; if (a == string(a.rbegin(), a.rend())) return true; else return false;&#125; 方法2：1234567bool isPalindrome(string a) &#123; for (int i = 0, j = a.length() - 1; i &lt; j; i++, j--) &#123; if (a[i] != a[j]) return false; &#125; return true;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[计算机网络入门汇总]]></title>
      <url>%2Flearn-computer-network%2F</url>
      <content type="text"><![CDATA[学习计算机网络的原理 入门读物2017新出炉的日本科普书 《网络是怎样连接的》 绝对是最合适的入门书！！ 经典教材： Kurose 的 《自顶向下方法》 被很多人推荐，据说比特南鲍姆那本要好。配合 中国大学MOOC 上哈工大的网络课程使用更佳。教学顺序一样 谢希仁的 《计算机网络》 已经出到第七版，考研指定参考书，评价不错]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法学习资料]]></title>
      <url>%2Flearn-data-structure-and-algorithm%2F</url>
      <content type="text"><![CDATA[Programs = Data Structure + Algorithm 面向学习 清华邓俊辉的数据结构 估计是中文资料中最好的数据结构MOOC，使用C++描述。 浙大陈越姥姥的数据结构 面向考试 《数据结构高分笔记》 购买链接请关注率辉学长的公众号：shuaihui_ds 率辉学长为18考研出了专栏，已经开始更新了，在他的公众号里 面向Java程序员 算法第4版 (Ps:作者是高德纳的学生) 应该是最好的选择 同时配合Coursera上普林斯顿的课程，直接打通。 面向天才 计算机程序设计艺术（第1卷） : 基本算法 算法导论（原书第3版） 做题 CodeVS PAT ，高分者会有名企通知面试（Ps：牛客网有优惠券活动，能减50元报名费） 算法笔记 江湖人称晴神宝典的PAT上机指南，共两本。刷两遍书，PAT甲级差不多能考满分了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编程语言入门汇总]]></title>
      <url>%2Flearn-program-from-scratch%2F</url>
      <content type="text"><![CDATA[汇总一下各编程语言学习资料 Python如果你之前没接触过编程，那么以Python上手无疑是最好的。 零基础入门: 一定要首推良心中国大学MOOC上北京理工大学嵩天老师Python系列>&gt;Python语言程序设计 >&gt;Python 网络爬虫与信息提取 >&gt;Python 数据分析与展示 >&gt;Python 机器学习应用 >&gt;Python 科学计算三维可视化 >&gt;Python 游戏开发入门 >&gt;Python 云端系统开发入门这样跟下来就可用学到Python在各个领域的应用了，真是不得了~ 廖雪峰的Python教程这个教程是大家口口相传的良心入门资料，经过群众检验的好东西~ Udacity的CS入门课 优达学城真是良心啊！通过这门课可以学到Python、搭建搜索引擎和社交网络 Python编程快速上手：让繁琐工作自动化 Python编程：从入门到实践 C语言 零基础入门: 计算导论与C语言基础 C程序设计进阶 PKU李戈教授在Coursea上的课程，可以说李老师是我看过所有MOOC中讲课最精彩的。富有激情，生动有趣，总能把知识点讲解透彻。另外，李戈老师在PKU的课程录像放在了北大公开课，相比慕课版有不少学生的讨论的环节。 C语言程序设计 : 现代方法 哈佛、麻省理工、斯坦福的C语言教材。比《C Primer Plus》生动些。 经典必看: C程序设计语言 : 第 2 版·新版 俗称K&amp;R，C语言之父的作品。不适合入门，但入门之后必看。 C++讲真，如果你不是非要用C++，那就不要学。Life is too short to program in C++! 当然，想练习算法题的话，C++是很好的选择，特别是运行时间受限时。使用C语言加上C++的STL部分就够了。 零基础入门: C++程序设计（原书第3版） 这本书是很多学校的教材。作者梁勇，美国教授，他编写的教材特点是适合初学者。如果你嫌看书枯燥，那么以此书为上课教材的 北邮C++程序设计(网易云课堂) 可搭配食用 C++ Primer（第 5 版） 如果你之前有过C语言基础，那么这本全明星阵容的经典适合你。读完这本你就入门了！ Java零基础入门： Java核心技术·卷Ⅰ对比了网上推荐的众多经典书籍，我选定了这本作为我的入门教材。目前出到了第10版，基于 Java 8 ，非常新，面向零基础。 经典必看： Java编程思想如果想深入理解Java面向对象的思想，这本书不可或缺。 Android方向： 第一行代码：Android（第2版）需要有Java基础，16年新出的。 Google参与制作的 Android 开发入门（中/英）面向零基础，不会Java也行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git与GitHub入门]]></title>
      <url>%2Flearn-git-and-github%2F</url>
      <content type="text"><![CDATA[Git和GitHub的学习资料 推荐学习路径廖雪峰 Git 教程 -&gt; Pro Git 入门书：Pro Git 文字教程：廖雪峰的 Git 教程 视频教程：如何使用 Git 和 GitHub 交互式教程：Try Git 以上几个教程都是适合新手的。学习 Git，不必陷入繁杂的细节，先记住最常用的几个操作就能完成绝大场景下的使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大学数学学习资源推荐]]></title>
      <url>%2F%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90%2F</url>
      <content type="text"><![CDATA[汇总一下数学学习资料 微积分 浙大名师苏德矿的课堂录制版，非常详细 传送门 哈工大尹逊波老师的微积分课，评价非常好，老师很有人格魅力。传送门线性代数MIT的线性代数，Gilbert Strang 讲授，非常非常好。网易公开课和B站 有中文字幕，还有习题课的视频概率论与数理统计如果是计算机专业的同学，那么南京大学的概率论MOOC一定不能错过~使用Python辅助教学]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web学习资料汇总]]></title>
      <url>%2Flearn-web-development%2F</url>
      <content type="text"><![CDATA[整理一下web学习资料 前端入门: Head First HTML与CSS（第2版） JavaScript DOM编程艺术 （第2版） 发现一个灰常好的英文资料，涵盖了前端的方方面面，而且每年更新：Front-End Developer Handbook 2017 后端： 还没研究，，好像技术栈很多= =]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1064. 朋友数(20)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1064-%E6%9C%8B%E5%8F%8B%E6%95%B0-20%2F</url>
      <content type="text"><![CDATA[如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如123和51就是朋友数，因为1+2+3 = 5+1 = 6，而6就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。注意：我们默认一个整数自己是自己的朋友。 输入格式：输入第一行给出正整数N。随后一行给出N个正整数，数字间以空格分隔。题目保证所有数字小于104。 输出格式：首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。 输入样例：8123 899 51 998 27 33 36 12 输出样例：43 6 9 26 题解1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main() &#123; int n, a[40] = &#123; 0 &#125;; cin &gt;&gt; n; while (n--) &#123; int num, sum = 0; cin &gt;&gt; num; while (num) &#123; sum += num % 10; num /= 10; &#125; a[sum]++; &#125; int k = 0, ans[40] = &#123; 0 &#125;, i; for (i = 0; i &lt; 40; i++) &#123; if (a[i]) &#123; ans[k] = i; k++; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl; for (i = 0; i &lt; k; i++) &#123; cout &lt;&lt; ans[i]; if (i != k - 1) cout &lt;&lt; " "; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1057. 数零壹(20)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1057-%E6%95%B0%E9%9B%B6%E5%A3%B9-20%2F</url>
      <content type="text"><![CDATA[给定一串长度不超过105的字符串，本题要求你将其中所有英文字母的序号（字母a-z对应序号1-26，不分大小写）相加，得到整数N，然后再分析一下N的二进制表示中有多少0、多少1。例如给定字符串“PAT (Basic)”，其字母序号之和为：16+1+20+2+1+19+9+3=71，而71的二进制是1000111，即有3个0、4个1。 输入格式：输入在一行中给出长度不超过105、以回车结束的字符串。 输出格式：在一行中先后输出0的个数和1的个数，其间以空格分隔。 输入样例：PAT (Basic) 输出样例：3 4 题解：1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; getline(cin, s); int sum = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s[i] &gt;= 'a'&amp;&amp;s[i] &lt;= 'z') sum += (int)(s[i] - 'a' + 1); else if (s[i] &gt;= 'A'&amp;&amp;s[i] &lt;= 'Z') sum += (int)(s[i] - 'A' + 1); &#125; int zero=0, one=0; while (sum) &#123; int rem = sum % 2; rem == 0 ? zero++ : one++; sum /= 2; &#125; cout &lt;&lt; zero &lt;&lt;" "&lt;&lt; one; return 0;&#125; cin&gt;&gt;s;遇到空格就结束输入了，要使用geiline()输入整行，可是我不会啊不会啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1004. 成绩排名(20)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D-20%2F</url>
      <content type="text"><![CDATA[读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含1个测试用例，格式为 第1行：正整数n 第2行：第1个学生的姓名 学号 成绩 第3行：第2个学生的姓名 学号 成绩 … … … 第n+1行：第n个学生的姓名 学号 成绩其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。 输入样例：3Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例：Mike CS991301Joe Math990112 题解：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct stu &#123; string name; string id; int score;&#125;;int main() &#123; int max = 0, min = 100; int n,first,last; cin &gt;&gt; n; vector&lt;stu&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].name &gt;&gt; a[i].id &gt;&gt; a[i].score; if (a[i].score &gt; max) &#123; max = a[i].score; first = i; &#125; if (a[i].score &lt; min) &#123; min = a[i].score; last = i; &#125; &#125; cout &lt;&lt; a[first].name &lt;&lt; " " &lt;&lt; a[first].id&lt;&lt;endl; cout &lt;&lt; a[last].name &lt;&lt; " " &lt;&lt; a[last].id &lt;&lt; endl; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1003. 我要通过！(20)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81-20%2F</url>
      <content type="text"><![CDATA[“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是： 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。输入格式：每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。输入样例：8PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA输出样例：YESYESYESYESNONONONO题解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool judge(string str) &#123; int len = str.length(); if (len &lt;= 2) return false; bool book[3] = &#123; false &#125;; for (int i = 0; i &lt; len; i++) &#123; if (str[i] == 'P') book[0] = true; else if (str[i] == 'A') book[1] = true; else if (str[i] == 'T') book[2] = true; else return false; if (str[i] == 'P') &#123; for (int j = 0; j &lt; i; j++) &#123; if (str[j] != 'A') return false; &#125; if (str[i + 1] != 'A') return false; for (int k = i + 2; k &lt; len; k++) &#123; if (str[k] != 'A') &#123; if (str[k] != 'T') return false; if ((len - 1 - k) != ((k - 1 - i) * i)) return false; for (int m = k + 1; m &lt; len; m++) &#123; if (str[m] != 'A') return false; &#125; &#125; &#125; &#125; &#125; if (book[0] == false || book[1] == false || book[2] == false) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; if (judge(s) == true) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1002. 写出这个数 (20)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0-20%2F</url>
      <content type="text"><![CDATA[读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。 输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。 输入样例：1234567890987654321123456789 输出样例：yi san wu 题解：123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int len = s.length(), sum=0; for (int i = 0; i &lt; len; i++) sum += s[i] - '0'; string str[10] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu" &#125;; int *b = new int[len]; int j = 0; if (sum == 0) cout &lt;&lt; "ling"; else &#123; while (sum != 0) &#123; b[j] = sum % 10; sum = sum / 10; j++; &#125; &#125; for (int i = j - 1; i &gt;= 1; i--) cout &lt;&lt; str[b[i]] &lt;&lt; " "; cout &lt;&lt; str[b[0]]; //最后一位后不要空格 delete[] b; return 0;&#125; 这道题难在输出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1001. 害死人不偿命的(3n+1)猜想(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3-15%2F</url>
      <content type="text"><![CDATA[卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？ 输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。 输出格式：输出从n计算到1需要的步数。 输入样例：3 输出样例：5 题解：123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int n, step=0; cin &gt;&gt; n; while (n != 1) &#123; if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; step++; &#125; cout &lt;&lt; step; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1006. 换个格式输出整数(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0-15%2F</url>
      <content type="text"><![CDATA[让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1011. A+B和C(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1011-A-B%E5%92%8CC-15%2F</url>
      <content type="text"><![CDATA[给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否大于C。 输入格式：输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。 输出格式：对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。 输入样例：41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例：Case #1: falseCase #2: trueCase #3: trueCase #4: false 题解：123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; long a, b, c; //用int不全对 cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if ((a + b) &gt; c) cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": true"&lt;&lt;endl; else cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": false"&lt;&lt;endl; &#125; return 0;&#125; 给定区间[-2^31, 2^31]内的3个整数A、B和Ca,b,c用int存储是部分正确，换成long就对了，难道OJ是用32位的吗？？？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1016. 部分A+B(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1016-%E9%83%A8%E5%88%86A-B-15%2F</url>
      <content type="text"><![CDATA[正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。 现给定A、DA、B、DB，请编写程序计算PA + PB。 输入格式：输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 1010。 输出格式：在一行中输出PA + PB的值。 输入样例1：3862767 6 13530293 3 输出样例1：399 输入样例2：3862767 1 13530293 8 输出样例2：0 题解：12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; long long a, b, da, db; cin &gt;&gt; a &gt;&gt; da &gt;&gt; b &gt;&gt; db; long long pa = 0, pb = 0; while (a != 0) &#123; if (a % 10 == da) pa = pa * 10 + da; a = a / 10; &#125; while (b != 0) &#123; if (b % 10 == db) pb = pb * 10 + db; b = b / 10; &#125; cout&lt;&lt;pa + pb; return 0;&#125; 用int也能AC，那么。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1021. 个位数统计(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1-15%2F</url>
      <content type="text"><![CDATA[给定一个k位整数N = dk-110k-1 + … + d1101 + d0 (0&lt;=di&lt;=9, i=0,…,k-1, dk-1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。 输入格式：每个输入包含1个测试用例，即一个不超过1000位的正整数N。 输出格式：对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。 输入样例：100311 输出样例：0:21:33:1 题解：12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int len = s.length(); int a[10] = &#123;0&#125;; for (int i = 0; i &lt; len; i++) a[s[i] - '0']++; for (int i = 0; i &lt; 10; i++) &#123; if (a[i] != 0) cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; a[i] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1026. 程序运行时间(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4-15%2F</url>
      <content type="text"><![CDATA[要获得一个C语言程序的运行时间，常用的方法是调用头文件time.h，其中提供了clock()函数，可以捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”。同时还有一个常数CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数f的运行时间，我们只要在调用f之前先调用clock()，获得一个时钟打点数C1；在f执行完成后再调用clock()，获得另一个时钟打点数C2；两次获得的时钟打点数之差(C2-C1)就是f运行所消耗的时钟打点数，再除以常数CLK_TCK，就得到了以秒为单位的运行时间。这里不妨简单假设常数CLK_TCK为100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。 输入格式：输入在一行中顺序给出2个整数C1和C2。注意两次获得的时钟打点数肯定不相同，即C1 &lt; C2，并且取值在[0, 107]。 输出格式：在一行中输出被测函数运行的时间。运行时间必须按照“hh:mm:ss”（即2位的“时:分:秒”）格式输出；不足1秒的时间四舍五入到秒。 输入样例：123 4577973 输出样例：12:42:59 题解：123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; int c1, c2; cin &gt;&gt; c1 &gt;&gt; c2; int time = (int)((c2 - c1) / 100.0 + 0.5); int hh = time / 3600; time %= 3600; int mm = time / 60; int ss = time % 60; //setw设置宽度但不能补0，只好用printf了 printf("%02d:%02d:%02d", hh, mm, ss); return 0;&#125; 不知道C++中如何实现这种效果。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1031. 查验身份证(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81-15%2F</url>
      <content type="text"><![CDATA[一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式：输入第一行给出正整数N（&lt;= 100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出“All passed”。 输入样例1：432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1：12010X19890101123411010819671130186637070419881216001X 输入样例2：2320124198808240056110108196711301862 输出样例2：All passed 题解：12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;int w[20] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;;char change[15] = &#123;'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'&#125;;int main() &#123; int n; scanf("%d", &amp;n); bool flag = true; char str[20]; for(int i = 0; i &lt; n; i++) &#123; scanf("%s", str); int j, last = 0; for(j = 0; j &lt; 17; j++) &#123; if(!(str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')) break; last = last + (str[j] - '0') * w[j]; &#125; if(j &lt; 17) &#123; flag = false; printf("%s\n", str); &#125; else &#123; if(change[last % 11] != str[17]) &#123; flag = false; printf("%s\n", str); &#125; &#125; &#125; if(flag == true) &#123; printf("All passed\n"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1036. 跟奥巴马一起编程(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B-15%2F</url>
      <content type="text"><![CDATA[美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式：输入在一行中给出正方形边长N（3&lt;=N&lt;=20）和组成正方形边的某种字符C，间隔一个空格 输出格式：输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整） 输入样例：10 a 输出样例：aaaaaaaaaaa aa aa aaaaaaaaaaa 题解：1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int n; char c; cin &gt;&gt; n &gt;&gt; c; int m = (int)(n/2.0 + 0.5); //四舍五入 for (int i = 0; i &lt; n; i++) cout &lt;&lt; c; cout &lt;&lt; endl; for (int j = 0; j &lt; m - 2; j++) &#123; cout &lt;&lt; c; for (int k = 0; k &lt; n - 2; k++) cout &lt;&lt; " "; cout &lt;&lt; c &lt;&lt; endl; &#125; for (int i = 0; i &lt; n; i++) cout &lt;&lt; c; return 0;&#125; 拓展：这道题四舍五入是关键点= =下面给出浮点数的四舍五入实现方法1234double a; scanf("%f",&amp;a); int i = (int)(a/10.0 + 0.5)*10; //个位四舍五入 int j = (int)(a + 0.5); //四舍五入成整型float b = (int)((a * 100) + 0.5)/100.0; //保留两位小数 CodeVS 2235输入机票原价（3到4位的正整数，单位：元），再输入机票打折率（小数点后最多一位数字）。编程计算打折后机票的实际价格（单位：元。计算结果要将个位数四舍五入到十位数“元”）。输入只有一行两个数（两数间用一个空格分隔），第一个为整数，表示机票原价，第二个整数或实数（如是实数，小数点后最多1位数字）表示打折率。输入样例1：888 7输出样例1：620输入样例2：1255 7输出样例2：880输入描述 Input Description输入只有一行两个数（两数间用一个空格分隔），第一个为整数，表示机票原价，第二个整数或实数（如是实数，小数点后最多1位数字）表示打折率。输出描述 Output Description输出只有一行一个正整数，表示打折后的机票价格。样例输入 Sample Input888 7样例输出 Sample Output620数据范围及提示 Data Size &amp; Hint原机票价格大于100小于9999，打折率大于1小于9.9。1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; int raw; float rate; cin&gt;&gt;raw&gt;&gt;rate; int price=(int)raw*rate*0.1; price=(price+5)/10*10; cout&lt;&lt;price; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1041. 考试座位号(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7-15%2F</url>
      <content type="text"><![CDATA[每个PAT考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数N（&lt;=1000），随后N行，每行给出一个考生的信息：“准考证号 试机座位号 考试座位号”。其中准考证号由14位数字组成，座位从1到N编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。考生信息之后，给出一个正整数M（&lt;=N），随后一行中给出M个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用1个空格分隔。 输入样例：410120150912233 2 410120150912119 4 110120150912126 1 310120150912002 3 223 4 输出样例：10120150912002 210120150912119 1 题解：123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct stu &#123; string id; int test, exam;&#125;;int main() &#123; int n, m,temp; cin &gt;&gt; n; vector&lt;stu&gt; a(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].id &gt;&gt; a[i].test &gt;&gt; a[i].exam; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; temp; for (int j = 0; j &lt; n; j++) &#123; if (a[j].test == temp) &#123; cout &lt;&lt; a[j].id&lt;&lt; " " &lt;&lt; a[j].exam &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 疑问：比如按输入样例那样输入，为什么可以在最后一行输入3 4后，将两个结果一起输出出来？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1046. 划拳(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1046-%E5%88%92%E6%8B%B3-15%2F</url>
      <content type="text"><![CDATA[划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。 输入格式：输入第一行先给出一个正整数N（&lt;=100），随后N行，每行给出一轮划拳的记录，格式为：甲喊 甲划 乙喊 乙划其中“喊”是喊出的数字，“划”是划出的数字，均为不超过100的正整数（两只手一起划）。 输出格式：在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。 输入样例：58 10 9 125 10 5 103 8 5 1212 18 1 134 16 12 15 输出样例：1 2 题解：1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int n,jiaDrink=0,yiDrink=0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; int jiaHan,jiaHua,yiHan,yiHua; cin&gt;&gt;jiaHan&gt;&gt;jiaHua&gt;&gt;yiHan&gt;&gt;yiHua; int sum = jiaHan + yiHan; if(sum == jiaHua &amp;&amp; sum != yiHua) yiDrink++; else if(sum != jiaHua &amp;&amp; sum == yiHua) jiaDrink++; &#125; cout&lt;&lt;jiaDrink&lt;&lt;" "&lt;&lt;yiDrink; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1051. 复数乘法(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1051-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95-15%2F</url>
      <content type="text"><![CDATA[复数可以写成(A + Bi)的常规形式，其中A是实部，B是虚部，i是虚数单位，满足i2 = -1；也可以写成极坐标下的指数形式(R*e(Pi))，其中R是复数模，P是辐角，i是虚数单位，其等价于三角形式 R(cos(P) + isin(P))。现给定两个复数的R和P，要求输出两数乘积的常规形式。 输入格式：输入在一行中依次给出两个复数的R1, P1, R2, P2，数字间以空格分隔。 输出格式：在一行中按照“A+Bi”的格式输出两数乘积的常规形式，实部和虚部均保留2位小数。注意：如果B是负数，则应该写成“A-|B|i”的形式。 输入样例：2.3 3.5 5.2 0.4 输出样例：-8.68-8.23i 题解：12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; double r1,p1,r2,p2; cin&gt;&gt;r1&gt;&gt;p1&gt;&gt;r2&gt;&gt;p2; double a1 = r1 * cos(p1); double b1 = r1 * sin(p1); double a2 = r2 * cos(p2); double b2 = r2 * sin(p2); double a = a1*a2 - b1*b2; double b = a1*b2 + b1*a2; if (a + 0.005 &gt;= 0 &amp;&amp; a &lt; 0) printf("0.00"); else printf("%.2f", a); if(b &gt;= 0) printf("+%.2fi", b); else if (b + 0.01 &gt;= 0 &amp;&amp; b &lt; 0) printf("+0.00i"); else printf("%.2fi", b); return 0;&#125; cin要跟&gt;&gt;而不是&lt;&lt;分界点的判定是抄的= =暂时不太明白]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1056. 组合数的和(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1056-%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C-15%2F</url>
      <content type="text"><![CDATA[给定N个非0的个位数字，用其中任意2个数字都可以组合成1个2位的数字。要求所有可能组合出来的2位数字的和。例如给定2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。 输入格式：输入在一行中先给出N（1&lt;N&lt;10），随后是N个不同的非0个位数字。数字间以空格分隔。 输出格式：输出所有可能组合出来的2位数字的和。 输入样例：3 2 8 5 输出样例：330 题解：123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int n, num[10]; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;num[i]; int temp,sum=0; for(int i = 0; i &lt; n-1; i++)&#123; for(int j = i+1; j &lt; n; j++)&#123; temp = num[i] + 10*num[j]; sum += temp; temp = 10*num[i] + num[j]; sum += temp; &#125; &#125; cout&lt;&lt;sum;&#125; 依次找出两数组合，调换个位十位的顺序可得两个数，都加到sum中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1061. 判断题(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1061-%E5%88%A4%E6%96%AD%E9%A2%98-15%2F</url>
      <content type="text"><![CDATA[判断题的评判很简单，本题就要求你写个简单的程序帮助老师判题并统计学生们判断题的得分。 输入格式：输入在第一行给出两个不超过100的正整数N和M，分别是学生人数和判断题数量。第二行给出M个不超过5的正整数，是每道题的满分值。第三行给出每道题对应的正确答案，0代表“非”，1代表“是”。随后N行，每行给出一个学生的解答。数字间均以空格分隔。 输出格式：按照输入的顺序输出每个学生的得分，每个分数占一行。 输入样例：3 62 1 3 3 4 50 0 1 0 1 10 1 1 0 0 11 0 1 0 1 01 1 0 0 1 1 输出样例：131112 题解：1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; //输入分值 int value[100]; for (int i = 0; i &lt; m; i++) cin &gt;&gt; value[i]; //输入标准答案 int stdAns[100]; for (int i = 0; i &lt; m; i++) cin &gt;&gt; stdAns[i]; //输入学生答案并输出成绩 for (int i = 0; i &lt; n; i++) &#123; int total = 0; for (int j = 0; j &lt; m; j++) &#123; int opt; cin&gt;&gt;opt; if (opt == stdAns[j]) total += value[j]; &#125; cout&lt;&lt;total&lt;&lt;endl; &#125; return 0;&#125; 弱鸡还没学会使用STL，幸好这道题能开大数组。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT(乙级) 1066. 图像过滤(15)]]></title>
      <url>%2FPAT-%E4%B9%99%E7%BA%A7-1066-%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4-15%2F</url>
      <content type="text"><![CDATA[图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。 输入格式：输入在第一行给出一幅图像的分辨率，即两个正整数M和N（0 &lt; M, N &lt;= 500），另外是待过滤的灰度值区间端点A和B（0 &lt;= A &lt; B &lt;= 255）、以及指定的替换灰度值。随后M行，每行给出N个像素点的灰度值，其间以空格分隔。所有灰度值都在[0, 255]区间内。 输出格式：输出按要求过滤后的图像。即输出M行，每行N个像素灰度值，每个灰度值占3位（例如黑色要显示为000），其间以一个空格分隔。行首尾不得有多余空格。 输入样例：3 5 100 150 03 189 254 101 119150 233 151 99 10088 123 149 0 255 输出样例：003 189 254 000 000000 233 151 099 000088 000 000 000 255 题解：1234567891011121314151617#include &lt;cstdio&gt;int main()&#123; int m, n, a, b, num, raw; scanf("%d%d%d%d%d", &amp;m, &amp;n, &amp;a, &amp;b, &amp;num); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf("%d", &amp;raw); if (raw &gt;= a &amp;&amp; raw &lt;= b) raw = num; if (j != 0) printf(" "); printf("%03d", raw); &#125; printf("\n"); &#125; return 0;&#125; 数组必须要用常数来定义，而这个题无法预知数组大小，但同时可以抛开数组采用“输入-处理-输出”的方法，不做中间保存。另外这道题可以先根据条件开辟一个大数组，然后“输入-保存-处理-输出”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeVS[青铜] 1205 单词翻转]]></title>
      <url>%2Fcodevs-1205-%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[给出一个英语句子，希望你把句子里的单词顺序都翻转过来 输入描述 Input Description输入包括一个英语句子。 输出描述 Output Description按单词的顺序把单词倒序输出 样例输入 Sample InputI love you 样例输出 Sample Outputyou love I 数据范围及提示 Data Size &amp; Hint简单的字符串操作 题解1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string a, b; cin &gt;&gt; a; while (cin &gt;&gt; b) a = b + " " + a; cout &lt;&lt; a; return 0;&#125; 真是简洁优雅，能一下想到的肯定是大神吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeVS[青铜] 1204 寻找子串位置]]></title>
      <url>%2Fcodevs-1204-%E5%AF%BB%E6%89%BE%E5%AD%90%E4%B8%B2%E4%BD%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[给出字符串a和字符串b，保证b是a的一个子串，请你输出b在a中第一次出现的位置。 输入描述 Input Description仅一行包含两个字符串a和b 输出描述 Output Description仅一行一个整数 样例输入 Sample Inputabcd bc 样例输出 Sample Output2 数据范围及提示 Data Size &amp; Hint字符串的长度均不超过100 题解12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; int alen = a.length(); int blen = b.length(); int num = 0; for (int i = 0; i&lt;alen; i++) &#123; for (int j = 0; j &lt; blen; j++) &#123; if (b[j] != a[i + j]) break; else if(b[j] == a[i+j]) &#123; num = j+1; continue; &#125; &#125; if (num == blen) &#123; cout &lt;&lt; i+1; return 0; &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A+B输入输出练习]]></title>
      <url>%2FA%2BB%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[本文给出 Codeup 上 A+B输入输出练习 关键代码Codeup.cn 已经挂了= = 1000123while(scanf("%d%d",&amp;a,&amp;b) != EOF)&#123; printf("%d\n", a+b); &#125; 100112345scanf("%d",&amp;n); while(n--)&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",a+b); &#125; 100212345scanf("%d %d",&amp;a,&amp;b);while((a!=0)||(b!=0))&#123; printf("%d\n", a+b); scanf("%d %d",&amp;a,&amp;b);&#125; 1003123456789101112131415#include &lt;cstdio&gt;int main()&#123; int N = 0; scanf("%d",&amp;N); while(N!=0)&#123; int sum = 0, num = 0; //使用变量num接收N个数相加 for(int i=0;i&lt;N;i++)&#123; scanf("%d",&amp;num); sum+=num; &#125; printf("%d\n",sum); scanf("%d",&amp;N); &#125; return 0;&#125; 1004123456789101112131415#include &lt;cstdio&gt;int main()&#123; int N = 0, M = 0; scanf("%d",&amp;N); for(int i=0;i&lt;N;i++)&#123; scanf("%d",&amp;M); int sum = 0,num = 0; for(int j=0;j&lt;M;j++)&#123; scanf("%d",&amp;num); sum += num; &#125; //算出此行的和 printf("%d\n",sum); &#125; //打印出所有行的和 return 0;&#125; 10051234567891011121314#include &lt;cstdio&gt; int main()&#123; int N = 0; //关键点在于结束判定 while(scanf("%d",&amp;N) != EOF)&#123; int sum = 0, num = 0; for(int i=0;i&lt;N;i++)&#123; scanf("%d", &amp;num); sum += num; &#125; printf("%d\n",sum); &#125; return 0; &#125; 100612345678#include &lt;cstdio&gt;int main()&#123; int a=0,b=0; while(scanf("%d %d",&amp;a,&amp;b) != EOF)&#123; printf("%d\n\n", a+b); &#125;return 0;&#125; 1007123456789101112131415#include &lt;cstdio&gt;int main()&#123; int N = 0, M = 0; scanf("%d",&amp;N); for(int i=0;i&lt;N;i++)&#123; scanf("%d",&amp;M); int sum = 0,num = 0; for(int j=0;j&lt;M;j++)&#123; scanf("%d",&amp;num); sum += num; &#125; //算出此行的和 printf("%d\n\n",sum); //比1004多了一个\n &#125; //打印出所有行的和 return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Deepin操作系统下安装OpenCV]]></title>
      <url>%2Fdeepin-install-opencv%2F</url>
      <content type="text"><![CDATA[在国产Linux发行版Deepin上使用OpenCV。 装系统Deepin是一个国产的linux发行版，因为其极高的颜值和不需要折腾的操作吸引了我。正好厌倦了windows 10，又赶上大四的毕业设计，就拿来玩玩了。首先,Deepin系统的安装是非常傻瓜式的，参照官网上的教程 几步就可装好。我采用的是体验安装，重启之后即可选择进入Deepin系统。 配置IDE写Python的应该都知道JetBrain家族的PyCharm好用,而这个家族的IDE们风格一致,使用体验好,所以C++也用他家的Clion吧。//如果是学生的话可以通过认证来获得免费的专业版许可证，实在良心。Deepin的深度商店里是Clion的，然鹅不是最新版，所以最好在官网 下载,然后解压缩，找到Clion.sh文件双击运行开始安装。//这里会出现一个问题，由于CLion是使用CMake Toolchain来编译，安装时会提示C++ Complier: not found 。解决方案为，在终端输入指令 sudo apt-get install g++，等待安装完成即可。 安装openCV下载官网下载：http://opencv.org/downloads.html 选择opencv3.2.0 linux 然后解压缩 安装依赖安装编译OpenCV的一些依赖 12345sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 进入opencv3.2.0文件夹（cd ~/opencv-3.1.0）执行： 123mkdir buildcd build 配置opencv文件12345cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..sudo makesudo make install 这样OpenCV3.2.0 就安装成功了 参考资料1]https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=44751&amp;highlight=clion2]https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=43127&amp;extra=]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我是怎样搭建这个博客的]]></title>
      <url>%2Fbuild-hexo-blog%2F</url>
      <content type="text"><![CDATA[Build your own Blog step by step from scratch本文并不完善，有时间填坑 注意~过程中可能会有报错，请不要放弃，多使用搜索引擎搜索报错信息。本人是在第四次尝试时才搭建成功，最后一次捣鼓了一整天终于弄好。所以坚持下去，你也会有自己的博客~ 准备工作注册Github 注册个人账号 创建一个新仓库，并命名为：你的用户名.github.io 环境安装 安装Node.js 安装Git 打开Git Bash，输入 123git config --global user.name &quot;你的github用户名&quot;git config --global user.email &quot;你的github注册邮箱&quot; 安装Hexo 1npm install -g hexo-cli 博客初始化 选择你的保存路径，打开命令行（这里推荐windows下的Cmder），输入 1hexo init blog 成功后，输入 1hexo g 这一步是使用hexo生成博客，不过还在本地。 （可选）在本地预览博客效果 1hexo d 会提示你可以浏览http://localhost:4000/ 查看 部署到github 意思就是上传到github上托管 主题设置hexo官网 挑选喜欢的主题 想要设置我这个主题的请看 这篇 发表文章在cmd中切换到hexo目录，输入 1hexo n 你的文章名字 然后用文件管理器打开 hexo安装目录\source\_post找到新建的MD文件，使用Markdown语法进行写作 注意文档头的设置信息，可选项有标题、时间、分类、标签、是否开启目录、是否开放评论。 (这里推荐Windows下一款Markdown编辑器Typora，灰常好用。 保存完成后在命令行输入 1hexo g -d 这是生成并部署的简写。刷新你的页面，就可以看到更新了~ (可选)安装插件评论组件可选的的有网易云跟帖、友言等 流量统计可以使用百度统计 绑定域名参考链接Hexo教程https://zhuanlan.zhihu.com/p/25471760 主题教程 之前使用的主题：https://www.haomwei.com/technology/maupassant-hexo.html 现在使用的主题：https://github.com/monniya/hexo-theme-new-vno]]></content>
    </entry>

    
  
  
</search>
